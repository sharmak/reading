Pragmatic Programmer
====================
Prgamatic Philosophy
--------------------
  - The Cat Ate My Source Code
      - Take responsibility
      - Provide option don't make lame excuses
  - Software Entropy
     - Don't live with broken windows
  - Stone Soup and Boiled Frogs
     - Be Catalyst for change
     - Remember big picture
  - Good Enough Software
    - Make Quality a requirement issue
  - Your knowledge portfolio
    - Invest Regularly
    - Diversify
    - Manage Risk
    - Buy low, Sell High
    - Review and Rebalance
  - Critical Thinking
    - Critically analyze what you read and hear
  - Communicate
    - Know what you want to say
    - Know your audience
    - Choose your moment
    - Make it look good
    - Involve your audience
    - Get back to people

A Prgamatic Approach
--------------------
- The Evils of duplication
  - DRY Don't Repeat Yourself
  - Imposed duplication
  - Documentation and code
  - Language Issue - header files are copied in c++
  - Inadvertent Duplication
    - Because of design mistake e.g. having an attribute as age when dob is already stored
  - Impatient Duplication
  - Interdeveloper Duplication
    - Make it easy to reuse
- Orthogonality 
  - Non orthogonal system  e.g. helicoper controls
  - Eliminate effect between unrelated stuff
  - This reduces risk e.g. if a module is sick, it is less likely to spread disease
  - Project team should be orthogonal except infrastructure team like database etc.
  - Keep your code decoupled
  - Avoid global data
  - Avoid similar functions
- Reversibility 
  - Nothing is more dangerous than an idea if it's only one you have
  - There are no final decisions
  - Flexible architecture
- Tracer bullets (Ready, fire, aim)
  - Use tracer bullets to find the target
  - Advantages 
    - Users get to see something working early
    - Developers build a structure to work in
    - You have an integration platform
    - You will have something to demonstrate
    - You have a better feel for progress
- Tracer Bullet vs Prototype
  - Prototype are generally thrown after requirements are finalized and you recode it.
  - We can create a prototype using GUI tools
  - In tracer bullet you try to build up things.
  - Prototype are cheaper than full production code
  - Things to prototype
    - Architecture
    - New functionality in existing system
    - Structure or contents of external data
    - third party tools
    - performance issues
    - user interface design
  - How to use prototype 
    - Correctness
    - Completeness
    - Robustness
    - Style
  - Prototyping architecture 
    - Are the responsibility of major componenets well defined and appropriate ?
    - Are the collaboration between major components are well defined ?
    - Is coupling minimized ?
    - Can you identify potential source of duplication ?
    - Are the interface definition and contraints acceptable ?
  - Domain Languages
    - Program close to the problem domain
    - Implement a mini language
    - Stand Alone and embedded language
  - Estimating 
    - Estimate to avoid suprises
    - How accurate is enough ?
    
The Basic Tools
---------------
  - Power of Plain Text
    - Keep knowledge in plain text
    - Insurance against obsolescence
    - Leverage 
  - Shell Games 
    - find . -name '*.c' -newer Makfile -print
    - find . -name '*.java' -mtime +7 -print | xargs grep 'java.awt'
    - Use power of shell commands
    - You can use unix command in windows using power shell.
  - Power Editing
    - One editior
    - Pick a powerful editor and learn it well
    - Try to reduce the keystrokes whereever possible
  - Source Code Control
    - Always use source code control
  - Debugging 
    - Fix the problem, not the blame
    - Don't panic
    - Visulaize your data
    - Tracing 
    - Rubber Ducking - Try to explain problem to fellow programmer
    - Process of elimination - "select" is n't broken
    - Element of surprise - Don't Assume It - Prove It
  - Text Manipulation
    - Learn a text manipulation language
    - We can use text manipulation language 
      - Database schema maintenance
      - Java Property access
      - Documentation generation
      - Test data generation
  - Code Generator
    - Passive code generator are run once e.g. change the format from a to b
    - Active code generator reproduce the new file each time it is ran e.g. swig
    - Active code generator need't be complex.
  

